"""
Trends Analysis Tool - Optimized for LLM consumption.

Key improvements:
- Flattened response structure (no deep nesting)
- Semantic field names (trend_direction vs raw slope)
- Consistent error handling
- Added interpretation fields for LLM
- Removed redundant/intermediate data
"""

import json
import logging
from typing import Any

from langchain_core.tools import tool

from ...services.redis_apple_health_manager import redis_manager
from ...utils.exceptions import HealthDataNotFoundError, ToolExecutionError
from ...utils.health_analytics import (
    calculate_weight_trends,
    compare_time_periods,
)
from ...utils.user_config import get_user_health_data_key

logger = logging.getLogger(__name__)


def _format_error(
    error_msg: str, analysis_type: str, metric_type: str | None = None
) -> dict[str, Any]:
    """Standardized error response for consistent LLM handling."""
    return {
        "success": False,
        "analysis_type": analysis_type,
        "metric_type": metric_type,
        "error": error_msg,
        "suggestion": "Try adjusting time periods or checking data availability",
    }


def _format_trend_response(raw_result: dict[str, Any]) -> dict[str, Any]:
    """
    Transform raw trend analysis into LLM-optimized format.

    Optimizations:
    - Flatten nested structure
    - Add semantic interpretations
    - Remove redundant data
    - Provide confidence indicators
    """
    if "error" in raw_result:
        return _format_error(
            raw_result["error"], "trend", raw_result.get("metric_type")
        )

    trends = raw_result.get("trends", {})
    linear = trends.get("linear_regression", {})
    stats = trends.get("statistics", {})

    # Determine confidence from RÂ²
    r_squared = linear.get("r_squared", 0)
    if r_squared > 0.8:
        confidence = "high"
    elif r_squared > 0.5:
        confidence = "moderate"
    else:
        confidence = "low"

    # Build interpretation
    direction = linear.get("trend_direction", "stable")
    slope_week = abs(linear.get("slope_per_week", 0))
    significance = linear.get("significance", "not_significant")

    if significance == "significant":
        interpretation = f"Metric is {direction} by {slope_week:.2f} units/week with {confidence} confidence"
    else:
        interpretation = f"No statistically significant trend detected ({confidence} confidence)"

    return {
        "success": True,
        "analysis_type": "trend",
        "time_period": raw_result.get("time_period"),
        "date_range": raw_result.get("date_range"),

        # Key trend metrics (flat structure)
        "trend_direction": direction,
        "slope_per_day": linear.get("slope", 0),
        "slope_per_week": linear.get("slope_per_week", 0),
        "slope_per_month": linear.get("slope_per_month", 0),

        # Statistical confidence
        "statistical_significance": significance,
        "confidence_level": confidence,
        "r_squared": r_squared,
        "p_value": linear.get("p_value", 1.0),

        # Summary statistics (essential only)
        "data_points": stats.get("measurements_count", 0),
        "average_value": stats.get("average_weight", 0),  # Note: rename needed in utils
        "std_deviation": stats.get("std_dev", 0),

        # LLM-friendly interpretation
        "interpretation": interpretation,
    }


def _format_comparison_response(raw_result: dict[str, Any]) -> dict[str, Any]:
    """
    Transform raw period comparison into LLM-optimized format.

    Optimizations:
    - Flatten nested period structures
    - Add clear semantic labels
    - Provide actionable interpretation
    """
    if "error" in raw_result:
        return _format_error(
            raw_result["error"], "comparison", raw_result.get("metric_type")
        )

    period1 = raw_result.get("period1", {})
    period2 = raw_result.get("period2", {})
    change = raw_result.get("change", {})
    stat_test = raw_result.get("statistical_test", {})

    # Build interpretation
    direction = change.get("direction", "no change")
    pct_change = abs(change.get("percentage", 0))
    is_significant = stat_test.get("significant", False)

    if is_significant:
        interpretation = f"Metric {direction}d by {pct_change:.1f}% (statistically significant)"
    else:
        interpretation = f"Metric {direction}d by {pct_change:.1f}% (not statistically significant)"

    return {
        "success": True,
        "analysis_type": "comparison",
        "metric_type": raw_result.get("metric_type"),

        # Period 1 (flattened)
        "period1_name": period1.get("name"),
        "period1_average": period1.get("average", 0),
        "period1_min": period1.get("min", 0),
        "period1_max": period1.get("max", 0),
        "period1_count": period1.get("count", 0),

        # Period 2 (flattened)
        "period2_name": period2.get("name"),
        "period2_average": period2.get("average", 0),
        "period2_min": period2.get("min", 0),
        "period2_max": period2.get("max", 0),
        "period2_count": period2.get("count", 0),

        # Change metrics
        "absolute_change": change.get("absolute", 0),
        "percent_change": change.get("percentage", 0),
        "change_direction": direction,

        # Statistical significance
        "is_significant": is_significant,
        "p_value": stat_test.get("p_value", 1.0),
        "t_statistic": stat_test.get("t_statistic", 0),

        # LLM-friendly interpretation
        "interpretation": interpretation,
    }


def create_get_trends_tool(user_id: str):
    """
    Create get_trends tool bound to a specific user.

    Args:
        user_id: The user identifier to bind to this tool

    Returns:
        LangChain tool instance optimized for LLM consumption
    """

    @tool
    def get_trends(
        metric_type: str,
        analysis_type: str = "comparison",
        period1: str | None = None,
        period2: str | None = None,
        time_period: str = "last_90_days",
        trend_type: str = "both",
    ) -> dict[str, Any]:
        """
        Analyze health metric trends or compare periods with statistical analysis.

        WHEN TO USE:
        â€¢ "Am I losing weight?" â†’ trend analysis
        â€¢ "Compare my weight this month vs last month" â†’ period comparison
        â€¢ "How is my heart rate trending?" â†’ trend analysis
        â€¢ "Show October vs September step count" â†’ period comparison

        WHEN NOT TO USE:
        â€¢ Raw data retrieval â†’ use get_health_metrics
        â€¢ Single period statistics â†’ use get_health_metrics
        â€¢ Workout-specific queries â†’ use get_workouts

        Args:
            metric_type: Health metric to analyze
                Examples: "BodyMass", "HeartRate", "StepCount", "BodyMassIndex"

            analysis_type: Type of analysis (default: "comparison")
                â€¢ "trend" = regression analysis over time
                â€¢ "comparison" = compare two time periods

            period1: First time period (required for comparison)
                Examples: "this month", "October 2025", "last 30 days"

            period2: Second time period (required for comparison)
                Examples: "last month", "September 2025", "previous 30 days"

            time_period: Time range for trend analysis (default: "last_90_days")
                Options: "last_90_days", "last_30_days", "this_month", "last_month"

            trend_type: Regression type for trend analysis (default: "both")
                Options: "linear_regression", "moving_average", "both"

        Returns:
            Flattened dictionary with analysis results and interpretation

        Examples:
            >>> get_trends(
            ...     metric_type="BodyMass",
            ...     analysis_type="trend",
            ...     time_period="last_30_days"
            ... )
            {
                "success": True,
                "analysis_type": "trend",
                "trend_direction": "decreasing",
                "slope_per_week": -0.35,
                "confidence_level": "high",
                "interpretation": "Metric is decreasing by 0.35 units/week with high confidence"
            }

            >>> get_trends(
            ...     metric_type="HeartRate",
            ...     analysis_type="comparison",
            ...     period1="this week",
            ...     period2="last week"
            ... )
            {
                "success": True,
                "analysis_type": "comparison",
                "period1_average": 72.5,
                "period2_average": 78.2,
                "percent_change": -7.3,
                "is_significant": True,
                "interpretation": "Metric decreased by 7.3% (statistically significant)"
            }
        """
        logger.info(
            f"ðŸ”§ get_trends: metric={metric_type}, analysis={analysis_type}, "
            f"p1={period1}, p2={period2}, user={user_id}"
        )

        try:
            with redis_manager.redis_manager.get_connection() as redis_client:
                main_key = get_user_health_data_key()
                health_data_json = redis_client.get(main_key)

                if not health_data_json:
                    raise HealthDataNotFoundError(user_id)

                health_data = json.loads(health_data_json)
                metrics_records = health_data.get("metrics_records", {})
                all_records = metrics_records.get(metric_type, [])

                if not all_records:
                    raise HealthDataNotFoundError(user_id, metric_types=[metric_type])

                # Branch based on analysis type
                if analysis_type == "trend":
                    raw_result = calculate_weight_trends(
                        all_records, time_period, trend_type
                    )
                    optimized_result = _format_trend_response(raw_result)
                    optimized_result["metric_type"] = metric_type
                    logger.info("âœ… Trend analysis complete")
                    return optimized_result

                elif analysis_type == "comparison":
                    if not period1 or not period2:
                        return _format_error(
                            "period1 and period2 are required for comparison analysis",
                            "comparison",
                            metric_type,
                        )

                    raw_result = compare_time_periods(
                        all_records, metric_type, period1, period2
                    )
                    optimized_result = _format_comparison_response(raw_result)
                    logger.info("âœ… Period comparison complete")
                    return optimized_result

                else:
                    return _format_error(
                        f"Invalid analysis_type: {analysis_type}. Must be 'trend' or 'comparison'",
                        analysis_type,
                        metric_type,
                    )

        except (HealthDataNotFoundError, ToolExecutionError):
            raise
        except Exception as e:
            raise ToolExecutionError("get_trends", str(e)) from e

    return get_trends
